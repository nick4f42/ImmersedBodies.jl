var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"import Pkg; Pkg.add(url=\"https://github.com/NUFgroup/ImmersedBodies.jl\")\n","category":"page"},{"location":"getting-started/#Example-Problem","page":"Getting Started","title":"Example Problem","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"First, load the ImmersedBodies package.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using ImmersedBodies","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Next, we define the fluid for the problem. The fluid domain is nlevel Cartesian grids that progressively double in scale. The smallest grid is at -1x1 -15y15. The fluid is specified with a Reynolds number of 200 and a freestream velocity of 1 along x. The grid step can be manually set by adding an h keyword argument to fluid_grid.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"fluid = Fluid(\n    grid = fluid_grid(xlims = (-1.0, 2.0), ylims = (-1.5, 1.5), nlevel = 5),\n    Re = 200.0,\n    freestream_vel = t -> (1.0, 0.0),\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Next, we define the bodies. In this case, 2 cylinders with the same radius at different heights. Each body is a StaticBody, meaning the body is stationary in the fluid grid. Each body is given a Panels argument that specifies the points on the body. You can manually specify points to use, or use the ImmersedBodies.Curves module to automatically discretize a curve that will work with the fluid grid.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"bodies = Bodies(\n    cyl1=StaticBody(\n        Panels(fluid.grid, Curves.Circle(r=0.5, center=(0.0, -0.75)))\n    ),\n    cyl2=StaticBody(\n        Panels(fluid.grid, Curves.Circle(r=0.5, center=(0.0, +0.75)))\n    ),\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Next, the time-stepping scheme. Here we automatically compute the time step to hit a target cfl number based on a given maximum fluid velocity Umax.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"scheme = default_scheme(fluid.grid; Umax=2.0, cfl=0.2)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Finally, we combine the fluid, bodies, and scheme into the problem.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"prob = Problem(; fluid, bodies, scheme)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We now solve the problem from time 0 to t and specify values to save to an HDF5 file. There are interfaces to the HDF5 file format for many programming languages, so you can analyze the data in whichever language you prefer.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"solve(\n    prob,\n    t=15.0,\n    save=SaveHDF5(\n        \"soln.h5\",\n        \"problem\" => prob,\n        \"fluid\" => fluid_group(\n            prob,\n            TimestepRange(; step=200),\n            (x_velocity!, y_velocity!, vorticity!)\n        ),\n        \"bodies\" => body_group(\n            prob,\n            TimestepRange(; step=10),\n            (boundary_force!,)\n        ),\n        \"totals\" => body_group(\n            prob,\n            TimestepRange(; step=1),\n            (boundary_total_force!,)\n        ),\n    ),\n)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Here is an example script for plotting the results in Julia with Makie.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using HDF5\nusing GLMakie\n\nfile = h5open(\"soln.h5\")\n\n# Load the positions of the two cylinders\nbodypos = NamedTuple(\n    name => read(file[\"problem/bodies/$name/positions\"]) for name in (:cyl1, :cyl2)\n)\n\n# Reference the vorticity dataset in the file. This doesn't load the data into memory until\n# we index it.\nvorticity_dset = file[\"fluid/vorticity\"]\n\n# The coords attribute stores the coordinates that correspond to the vorticity array. The\n# fields are `start`, `length`, and `step` to work directly with the `range` function.\n# `vort_coords[:, level]` are the coordinates on the `level`th subdomain.\nvort_coords = map(r -> range(; r...), read_attribute(vorticity_dset, \"coords\"))\n\n# Set up the Makie plot\nfig = Figure(resolution = (800, 400))\nax = Axis(fig[1, 1], aspect = DataAspect(), limits = ((-1.5, 8.5), (-2.5, 2.5)))\n\n# Plot contours of the vorticity in reverse order so that the smaller domains are plotted on\n# top\nlevels = reverse(axes(vorticity_dset, 3))\ncontours = map(levels) do lev\n    x, y = vort_coords[:, lev]\n    @views contourf!(\n        ax, x, y,\n        vorticity_dset[:, :, lev, end],\n        colormap = :RdBu,\n        levels = range(-5, 5, 12),\n        extendlow = :auto,\n        extendhigh = :auto,\n    )\nend\n\nColorbar(fig[1, 2], contours[1])\n\n# Plot the cylinder bodies\nfor pos in bodypos\n    poly!(ax, Point2.(eachrow(pos)), color = :gray)\nend\n\n# Create a gif by updating the vorticity plot\ntimes = axes(vorticity_dset, 4)\nrecord(fig, \"vorticity.gif\", times; framerate = 20) do i\n    ω = vorticity_dset[:, :, :, i]\n    for (level, contour) in zip(levels, contours)\n        contour[3] = @view ω[:, :, level]\n    end\nend","category":"page"},{"location":"examples/naca/#NACA","page":"NACA","title":"NACA","text":"","category":"section"},{"location":"examples/naca/","page":"NACA","title":"NACA","text":"using ImmersedBodies\nusing ImmersedBodies.Curves\n\nfluid = Fluid(\n    grid = fluid_grid(xlims=(-1.0, 2.0), ylims=(-0.5, 0.5), nlevel=3),\n    Re=400.0,\n    freestream_vel=t -> (1.0, 0.0),\n)\n\nα = deg2rad(20)\nairfoil = naca\"0012\" |> translate((-0.5, 0.0)) |> rotate(-α)\nbodies = Bodies(\n    airfoil=StaticBody(Panels(fluid.grid, airfoil)),\n)\n\nscheme = default_scheme(fluid.grid; Umax=2.0, cfl=0.2)\n\nprob = Problem(; fluid, bodies, scheme)\n\nsolve(\n    prob,\n    t=10.0,\n    save=SaveHDF5(\n        \"soln.h5\",\n        \"problem\" => prob,\n        \"fluid\" => fluid_group(\n            prob,\n            TimestepRange(; step=200),\n            (x_velocity!, y_velocity!, vorticity!)\n        ),\n        \"bodies\" => body_group(\n            prob,\n            TimestepRange(; step=10),\n            (boundary_force!,)\n        ),\n        \"totals\" => body_group(\n            prob,\n            TimestepRange(; step=1),\n            (boundary_total_force!,)\n        ),\n    ),\n)","category":"page"},{"location":"examples/naca/","page":"NACA","title":"NACA","text":"using HDF5\nusing GLMakie\n\nfile = h5open(\"soln.h5\")\n\nbodypos = read(file[\"problem/bodies/airfoil/positions\"])\nvorticity_dset = file[\"fluid/vorticity\"]\nvort_coords = map(r -> range(; r...), read_attribute(vorticity_dset, \"coords\"))\n\nfig = Figure(resolution = (800, 400))\n\nax = Axis(fig[1, 1], aspect = DataAspect(), limits = ((-1.5, 6.5), (-2, 2)))\n\nlevels = reverse(axes(vorticity_dset, 3))\ncontours = map(levels) do lev\n    x, y = vort_coords[:, lev]\n    @views contourf!(\n        ax, x, y,\n        vorticity_dset[:, :, lev, end],\n        colormap = :RdBu,\n        levels = range(-5, 5, 12),\n        extendlow = :auto,\n        extendhigh = :auto,\n    )\nend\n\nColorbar(fig[1, 2], contours[1])\n\npoly!(ax, Point2.(eachrow(bodypos)), color = :gray)\n\ntimes = axes(vorticity_dset, 4)\nrecord(fig, \"vorticity.gif\", times; framerate = 20) do i\n    ω = vorticity_dset[:, :, :, i]\n    for (level, contour) in zip(levels, contours)\n        contour[3] = @view ω[:, :, level]\n    end\nend","category":"page"},{"location":"reference/problems/","page":"Problems","title":"Problems","text":"CurrentModule = ImmersedBodies","category":"page"},{"location":"reference/problems/#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"reference/problems/#Fluid","page":"Problems","title":"Fluid","text":"","category":"section"},{"location":"reference/problems/","page":"Problems","title":"Problems","text":"gridstep\ngridsize\nextents\ncoords\nfluid_grid\nCartesianGrid\nMultiDomainGrid\nMultiDomainExtents\nsubdomain\nGridMotion\nStaticGrid\nMovingGrid\nGridVelocity\nFluid","category":"page"},{"location":"reference/problems/#ImmersedBodies.gridstep","page":"Problems","title":"ImmersedBodies.gridstep","text":"gridstep(::CartesianGrid)\n\nThe spacing between grid vertices.\n\n\n\n\n\ngridstep(::MultiDomainGrid, level=1)\n\nGrid step on the levelth multi domain level.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.gridsize","page":"Problems","title":"ImmersedBodies.gridsize","text":"gridsize(grid::CartesianGrid, pts::GridPoints=GridVertices())\n\nReturns the dimensions of an array of points on the grid.\n\n\n\n\n\ngridsize(grid::MultiDomainGrid, pts::GridPoints=GridVertices(), levels=:)\n\nThe dimensions of the multi domain grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.extents","page":"Problems","title":"ImmersedBodies.extents","text":"extents(::CartesianGrid) -> ((xmin, xmax), (ymin, ymax))\n\nMinimum and maximum coordinates of the grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.coords","page":"Problems","title":"ImmersedBodies.coords","text":"coords(grid::CartesianGrid, pts::GridPoints=GridVertices())\n\nReturns a tuple of ranges (x, y) such that (x[i], y[j]) is the coordinate of the point at index (i, j).\n\n\n\n\n\ncoords(grid::MultiDomainGrid, pts::GridPoints=GridVertices(), levels=:)\n\nReturn the coordinates of each CartesianGrid subdomain in levels.\n\n\n\n\n\ncoords(grid, func, ...)\n\nCoordinates of the quantity func on grid. func can be one of the following (or the in-place ! versions):\n\nx_velocity\ny_velocity\nvorticity\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.fluid_grid","page":"Problems","title":"ImmersedBodies.fluid_grid","text":"fluid_grid(; [h], xlims, ylims, nlevel)\n\nA cartesian grid with step h, limits xlims and ylims, and nlevel total grids that expand outward. Each grid has the same center point, and grid step h * 2 ^ (level - 1) for level in 1:nlevel. If h is included, return a MultiDomainGrid. Otherwise, return a MultiDomainExtents and the grid step will be automatically computed when passed to Fluid.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.CartesianGrid","page":"Problems","title":"ImmersedBodies.CartesianGrid","text":"CartesianGrid(h, xlims, ylims)\nCartesianGrid(; h, xlims, ylims)\n\nA Cartesian grid with grid step h.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.MultiDomainGrid","page":"Problems","title":"ImmersedBodies.MultiDomainGrid","text":"MultiDomainGrid(; h, xlims, ylims, nlevel)\n\nMultiple CartesianGrids with different scales, centered at the same point.\n\nSee also fluid_grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.MultiDomainExtents","page":"Problems","title":"ImmersedBodies.MultiDomainExtents","text":"MultiDomainExtents(; xlims, ylims, nlevel)\n\nThe region defined by a MultiDomainGrid, without the grid step.\n\nSee also fluid_grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.subdomain","page":"Problems","title":"ImmersedBodies.subdomain","text":"subdomain(grid::MultiDomainGrid, level) :: CartesianGrid\n\nReturn the levelth multi domain level of grid.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.GridMotion","page":"Problems","title":"ImmersedBodies.GridMotion","text":"GridMotion\n\nThe motion of the fluid discretization relative to the global frame in which the freestream velocity is expressed. Can be one of:\n\nStaticGrid\nMovingGrid\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.StaticGrid","page":"Problems","title":"ImmersedBodies.StaticGrid","text":"StaticGrid() :: GridMotion\n\nA grid that is static in the global frame.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.MovingGrid","page":"Problems","title":"ImmersedBodies.MovingGrid","text":"MovingGrid(f) :: GridMotion\n\nA grid that moves in global frame. f(t) should return a GridVelocity that expresses the current motion of the grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.GridVelocity","page":"Problems","title":"ImmersedBodies.GridVelocity","text":"GridVelocity(; center, vel, angle, angular_vel)\n\nThe current motion and orientation of the grid relative to the global frame.\n\nKeywords\n\ncenter: The center of rotation.\nvel: The grid's velocity in the global frame at the center of rotation.\nangle: The grid's orientation relative to the global frame in radians.\nangular_vel: The time rate of change of angle.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.Fluid","page":"Problems","title":"ImmersedBodies.Fluid","text":"Fluid(; grid, Re, freestream_vel, [grid_motion])\n\nKeywords\n\ngrid::Union{MultiDomainGrid,MultiDomainExtents}: The discretization of the fluid. See fluid_grid.\nRe: Reynolds number.\nfreestream_vel(t) -> (vx, vy): Freestream velocity as a function of time.\ngrid_motion::GridMotion: Whether the grid is moving relative to the global frame.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#Bodies","page":"Problems","title":"Bodies","text":"","category":"section"},{"location":"reference/problems/","page":"Problems","title":"Problems","text":"n_panels\nPanels\nPanelState\nAbstractBody\nPresetBody\nBodies\nPanelSection\nsection_body\npanel_range\nbodypanels\nStaticBody\nRigidBodyTransform\nMovingRigidBody","category":"page"},{"location":"reference/problems/#ImmersedBodies.n_panels","page":"Problems","title":"ImmersedBodies.n_panels","text":"n_panels(x)\n\nThe number of panels in a thing.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.Panels","page":"Problems","title":"ImmersedBodies.Panels","text":"Panels(x::AbstractMatrix, ds::AbstractVector)\n\nThe positions xb and lengths ds of panels that influence the fluid. xb has shape (n, 2) and ds has length n.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.PanelState","page":"Problems","title":"ImmersedBodies.PanelState","text":"PanelState(; xb::AbstractMatrix, ds::AbstractVector, ub::AbstractMatrix)\n\nThe positions xb, lengths ds, and velocities ub of panels that influence the fluid. xb and ub have shape (n, 2) and ds has length n.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.AbstractBody","page":"Problems","title":"ImmersedBodies.AbstractBody","text":"AbstractBody\n\nA body that can be immersed in the fluid.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.PresetBody","page":"Problems","title":"ImmersedBodies.PresetBody","text":"PresetBody <: AbstractBody\n\nA body that is not influenced by the fluid.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.Bodies","page":"Problems","title":"ImmersedBodies.Bodies","text":"Bodies(; bodies::AbstractBody...)\n\nA group of bodies. Keyword arguments specify bodies by their name.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.PanelSection","page":"Problems","title":"ImmersedBodies.PanelSection","text":"PanelSection\n\nSpecifies a subsection of the panels in Bodies.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.section_body","page":"Problems","title":"ImmersedBodies.section_body","text":"section_body(section::PanelSection)\n\nThe AbstractBody of a section.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.panel_range","page":"Problems","title":"ImmersedBodies.panel_range","text":"panel_range(bodies::Bodies, body::Symbol)\npanel_range(section::PanelSection)\n\nThe index range in the panels of the given body.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.bodypanels","page":"Problems","title":"ImmersedBodies.bodypanels","text":"bodypanels(body::AbstractBody)\n\nThe Panels of a body's reference state.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.StaticBody","page":"Problems","title":"ImmersedBodies.StaticBody","text":"StaticBody(panels::Panels) :: PresetBody\n\nA body that is fixed in place at panels.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.RigidBodyTransform","page":"Problems","title":"ImmersedBodies.RigidBodyTransform","text":"RigidBodyTransform(pos, vel, angle, angular_vel)\nRigidBodyTransform(; pos, vel, angle, angular_vel)\n\nThe transformation of a rigid body at a point in time. Relative to the global frame, the rigid body is at position (x, y) = pos, traveling at velocity (vx, vy) = vel, oriented at angle angle, and rotating at rate angular_vel.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.MovingRigidBody","page":"Problems","title":"ImmersedBodies.MovingRigidBody","text":"MovingRigidBody(panels::Panels, motion) :: PresetBody\n\nA non-deforming body with displacement and rotation over time. With zero displacement and zero angle, the body is at panels. motion(t) is the RigidBodyTransform of the body at time t.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#Time-stepping-Scheme","page":"Problems","title":"Time-stepping Scheme","text":"","category":"section"},{"location":"reference/problems/","page":"Problems","title":"Problems","text":"timestep\nAbstractScheme\ndefault_scheme\nCNAB","category":"page"},{"location":"reference/problems/#ImmersedBodies.timestep","page":"Problems","title":"ImmersedBodies.timestep","text":"timestep(prob::Problem)\ntimestep(scheme::AbstractScheme)\n\nThe time between consecutive time steps.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.AbstractScheme","page":"Problems","title":"ImmersedBodies.AbstractScheme","text":"AbstractScheme\n\nA time-stepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.default_scheme","page":"Problems","title":"ImmersedBodies.default_scheme","text":"default_scheme([T,] grid; Umax, [cfl])\n\nA default AbstractScheme to hit a target cfl number.\n\nArguments\n\nT::Type{<:AbstractScheme}: The type of scheme to return.\ngrid::Union{CartesianGrid,MultiDomainGrid}: The discretization of the fluid.\nUmax: The maximum fluid velocity relative to the discretization.\ncfl: Target CFL number.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.CNAB","page":"Problems","title":"ImmersedBodies.CNAB","text":"CNAB(; dt, n=2)\n\nAn n-step Crank-Nicolson/Adams-Bashforth timestepping scheme with time step dt.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#Problem","page":"Problems","title":"Problem","text":"","category":"section"},{"location":"reference/problems/","page":"Problems","title":"Problems","text":"Problem","category":"page"},{"location":"reference/problems/#ImmersedBodies.Problem","page":"Problems","title":"ImmersedBodies.Problem","text":"Problem(; fluid::Fluid, bodies::Bodies, scheme::AbstractScheme)\nProblem(fluid::Fluid, bodies::Bodies, scheme::AbstractScheme)\n\nA description of the immersed boundary problem to solve.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#State","page":"Problems","title":"State","text":"","category":"section"},{"location":"reference/problems/","page":"Problems","title":"Problems","text":"State\nx_velocity\ny_velocity\nvorticity\nboundary_pos\nboundary_len\nboundary_vel\nboundary_force\nboundary_total_force","category":"page"},{"location":"reference/problems/#ImmersedBodies.State","page":"Problems","title":"ImmersedBodies.State","text":"State(prob::Problem; t0=0.0)\n\nThe state of the prob system at a certain time step. t0 specifies the time at state.index == 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/problems/#ImmersedBodies.x_velocity","page":"Problems","title":"ImmersedBodies.x_velocity","text":"x_velocity(state, [levels])\n\nReturn the x velocity array of state on subdomain levels.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.y_velocity","page":"Problems","title":"ImmersedBodies.y_velocity","text":"y_velocity(state, [levels])\n\nReturn the y velocity array of state on subdomain levels.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.vorticity","page":"Problems","title":"ImmersedBodies.vorticity","text":"vorticity(state, [levels])\n\nReturn the vorticity array of state on subdomain levels.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.boundary_pos","page":"Problems","title":"ImmersedBodies.boundary_pos","text":"boundary_pos(state)\nboundary_pos(state, inds)\nboundary_pos(state, body::Symbol)\n\nReturn the positions of each panel point. In the first form, return all of the points. In the second form, return the points at indices inds. In the last form, return the points for the body named body.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.boundary_len","page":"Problems","title":"ImmersedBodies.boundary_len","text":"boundary_len(state)\nboundary_len(state, inds)\nboundary_len(state, body::Symbol)\n\nReturn the lengths of each panel. See boundary_pos for the meaning of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.boundary_vel","page":"Problems","title":"ImmersedBodies.boundary_vel","text":"boundary_vel(state)\nboundary_vel(state, inds)\nboundary_vel(state, body::Symbol)\n\nReturn the velocities of each panel. See boundary_pos for the meaning of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.boundary_force","page":"Problems","title":"ImmersedBodies.boundary_force","text":"boundary_(state)\nboundary_force(state, inds)\nboundary_force(state, body::Symbol)\n\nReturn the force on each panel by the fluid. See boundary_pos for the meaning of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/problems/#ImmersedBodies.boundary_total_force","page":"Problems","title":"ImmersedBodies.boundary_total_force","text":"boundary_total_force(state)\nboundary_total_force(state, inds)\nboundary_total_force(state, body::Symbol)\n\nThe total [x, y] force. See boundary_pos for the meaning of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/solving/","page":"Solving","title":"Solving","text":"CurrentModule = ImmersedBodies","category":"page"},{"location":"reference/solving/#Solving","page":"Solving","title":"Solving","text":"","category":"section"},{"location":"reference/solving/#Time-stepping","page":"Solving","title":"Time-stepping","text":"","category":"section"},{"location":"reference/solving/","page":"Solving","title":"Solving","text":"solve\nsolve!\nadvance!\nAbstractSolver","category":"page"},{"location":"reference/solving/#ImmersedBodies.solve","page":"Solving","title":"ImmersedBodies.solve","text":"solve([f], prob::Problem; t, [save], [solver_kw])\n\nSolve the problem from time 0 to t. See solve!.\n\n\n\n\n\n","category":"function"},{"location":"reference/solving/#ImmersedBodies.solve!","page":"Solving","title":"ImmersedBodies.solve!","text":"solve!([f], solver::AbstractSolver; t, save=SaveNothing(), log=true)\n\nSolve for the state up to time t, calling the function f(state, i, n) at each timestep i from 1:n. save is a SolutionSaver that determins how to write the solution.\n\n\n\n\n\n","category":"function"},{"location":"reference/solving/#ImmersedBodies.advance!","page":"Solving","title":"ImmersedBodies.advance!","text":"advance!(::AbstractSolver)\n\nCompute the state at the next time step in place.\n\n\n\n\n\n","category":"function"},{"location":"reference/solving/#ImmersedBodies.AbstractSolver","page":"Solving","title":"ImmersedBodies.AbstractSolver","text":"AbstractSolver\n\nSolves a Problem.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#Input/Output","page":"Solving","title":"Input/Output","text":"","category":"section"},{"location":"reference/solving/","page":"Solving","title":"Solving","text":"save_state\nload_state\nload_state!\nTimesteps\nTimestepRange\nSolutionValues\nSolutionValue\nArrayValue\nMultiDomainValue\nSolutionSaver\nSaveNothing\nSaveHDF5","category":"page"},{"location":"reference/solving/#ImmersedBodies.save_state","page":"Solving","title":"ImmersedBodies.save_state","text":"save_state(filename, state::State)\nsave_state(io, state::State)\n\nWrite the contents of a State to a file or IO stream. The result can be loaded with load_state.\n\n\n\n\n\n","category":"function"},{"location":"reference/solving/#ImmersedBodies.load_state","page":"Solving","title":"ImmersedBodies.load_state","text":"load_state(filename, prob::Problem)\nload_state(io, prob::Problem)\n\nRead the contents of a State from a file or IO stream. The state can be written with save_state.\n\n\n\n\n\n","category":"function"},{"location":"reference/solving/#ImmersedBodies.load_state!","page":"Solving","title":"ImmersedBodies.load_state!","text":"load_state!(filename, state::State)\nload_state!(io, state::State)\n\nload_state, but update state in place.\n\n\n\n\n\n","category":"function"},{"location":"reference/solving/#ImmersedBodies.Timesteps","page":"Solving","title":"ImmersedBodies.Timesteps","text":"Timesteps\n\nSpecifies timesteps to save the solution at.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.TimestepRange","page":"Solving","title":"ImmersedBodies.TimestepRange","text":"TimestepRange(; start, step, [length]) :: Timesteps\n\nSpecifies every stepth timestep starting at start. If specified, only include length timesteps.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.SolutionValues","page":"Solving","title":"ImmersedBodies.SolutionValues","text":"SolutionValues(times::Timesteps, vals)\nSolutionValues(times::Timesteps, vals...)\n\nSpecifies to save certain values at each time in times. vals is a collection of name => value mapping a name string to a SolutionValue.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.SolutionValue","page":"Solving","title":"ImmersedBodies.SolutionValue","text":"SolutionValue\n\nA function of State to be saved.\n\nSee also ArrayValue, MultiDomainValue.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.ArrayValue","page":"Solving","title":"ImmersedBodies.ArrayValue","text":"ArrayValue(f!, T, dims) :: SolutionValue\n\nA function f!(y, state) that sets an array y with size dims.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.MultiDomainValue","page":"Solving","title":"ImmersedBodies.MultiDomainValue","text":"MultiDomainValue(f!, coords::AbstractVector)\n\nA function f!(y, state) that sets a 3D array y with corresponding coordinates coords. array[i,j,level] should be at coordinate (x[i], y[j]) where (x, y) = coords[level].\n\nSee also coords.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.SolutionSaver","page":"Solving","title":"ImmersedBodies.SolutionSaver","text":"SolutionSaver\n\nA backend for saving SolutionValues at certain Timesteps.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.SaveNothing","page":"Solving","title":"ImmersedBodies.SaveNothing","text":"SaveNothing() :: SolutionSaver\n\nDo not save anything.\n\n\n\n\n\n","category":"type"},{"location":"reference/solving/#ImmersedBodies.SaveHDF5","page":"Solving","title":"ImmersedBodies.SaveHDF5","text":"HDF5Saver(file, paths...; [mode])\n\nSaves to the HDF5 file, filename, or group file. paths is pairs of path => val that specifies to save a representation of val at path in the HDF5 file. If file is a filename, open the file with mode. val can be an instance of:\n\nProblem\nSolutionValues\n\n\n\n\n\n","category":"type"},{"location":"#ImmersedBodies.jl","page":"Home","title":"ImmersedBodies.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia CFD package based on the Immersed Boundary Projection Method (IBPM) from Taira & Colonius (2007), with multigrid method from Colonius & Taira (2008).","category":"page"}]
}
